# ARGS: -f test.bril
@main(n: int) {
  # Initialize arrays
  size = const 1000;
  A: ptr<int> = alloc size;
  B: ptr<int> = alloc size;
  C: ptr<int> = alloc size;

  # Test Case 1: Row-major matrix multiplication
  zero: int = const 0;
  one: int = const 1;
  i: int = zero;
.loop_i:
  cond: bool = lt i size;
  br cond .body_i .done;
.body_i:
  j: int = zero;
.loop_j:
  cond2: bool = lt j size;
  br cond2 .body_j .done_j;
.body_j:
  k: int = zero;
  sum: int = const 0;
.loop_k:
  cond3: bool = lt k size;
  br cond3 .body_k .done_k;
.body_k:
  # C[i][j] += A[i][k] * B[k][j]
  idx_a: int = mul i size;
  idx_a: int = add idx_a k;
  val_a: int = load A idx_a;
  
  idx_b: int = mul k size;
  idx_b: int = add idx_b j;
  val_b: int = load B idx_b;
  
  prod: int = mul val_a val_b;
  sum: int = add sum prod;
  
  k: int = add k one;
  jmp .loop_k;
.done_k:
  idx_c: int = mul i size;
  idx_c: int = add idx_c j;
  store C idx_c sum;
  
  j: int = add j one;
  jmp .loop_j;
.done_j:
  i: int = add i one;
  jmp .loop_i;
.done:
  free A;
  free B;
  free C;
}

# Test Case 2: Column-major access pattern
@column_major_sum(size: int) {
  A: ptr<int> = alloc size;
  sum: int = const 0;
  zero: int = const 0;
  one: int = const 1;
  
  j: int = zero;
.loop_j:
  cond: bool = lt j size;
  br cond .body_j .done;
.body_j:
  i: int = zero;
.loop_i:
  cond2: bool = lt i size;
  br cond2 .body_i .done_i;
.body_i:
  # Column-major access: A[i + j * size]
  idx: int = mul j size;
  idx: int = add idx i;
  val: int = load A idx;
  sum: int = add sum val;
  
  i: int = add i one;
  jmp .loop_i;
.done_i:
  j: int = add j one;
  jmp .loop_j;
.done:
  free A;
  ret sum;
}

# Test Case 3: Blocked/Tiled access pattern
@blocked_access(size: int) {
  A: ptr<int> = alloc size;
  B: ptr<int> = alloc size;
  
  # Block size
  block: int = const 32;
  zero: int = const 0;
  one: int = const 1;
  
  ii: int = zero;
.loop_ii:
  cond: bool = lt ii size;
  br cond .body_ii .done;
.body_ii:
  jj: int = zero;
.loop_jj:
  cond2: bool = lt jj size;
  br cond2 .body_jj .done_jj;
.body_jj:
  i: int = ii;
.loop_i:
  max_i: int = add ii block;
  cond3: bool = lt i max_i;
  cond3: bool = lt i size;
  br cond3 .body_i .done_i;
.body_i:
  j: int = jj;
.loop_j:
  max_j: int = add jj block;
  cond4: bool = lt j max_j;
  cond4: bool = lt j size;
  br cond4 .body_j .done_j;
.body_j:
  # Blocked access pattern
  idx_a: int = mul i size;
  idx_a: int = add idx_a j;
  val_a: int = load A idx_a;
  
  idx_b: int = mul i size;
  idx_b: int = add idx_b j;
  store B idx_b val_a;
  
  j: int = add j one;
  jmp .loop_j;
.done_j:
  i: int = add i one;
  jmp .loop_i;
.done_i:
  jj: int = add jj block;
  jmp .loop_jj;
.done_jj:
  ii: int = add ii block;
  jmp .loop_ii;
.done:
  free A;
  free B;
}

